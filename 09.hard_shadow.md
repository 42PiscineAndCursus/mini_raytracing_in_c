# 9. 그림자

이번 장에서는 light로 인해 생기는 shadow에 대해서 구현하고자 한다.

## 9.1. 실습목표

>1. object와 light 사이에 또 다른 object가 존재할 때에 그림자가 발생하는데 이 그림자를 구현할 수 있다.

## 9.2. shadow

8단원에서는 여러 light를 사용하여 ambient를 구현했다. 하지만 빛이 있으면 반대로 그림자도 존재하는법. 우리는 이번 단원에서 그림자, 즉 hard shadow를 구현할 것이다. object에 반사가 전혀 일어나지 않는다는 가정하에 light와 object사이에 다른 object가 있으면 아무것도 보이지 않는 hardshadow를 적용할 것이다. 실재 현실에는 hard shadow가 아닌 soft shadow도 존재하지만 우리는 hard shadow만을 구현할 것이다.

그럼 먼저 in_shadow라는 함수를 만들어 보자.

```c
t_bool			in_shadow(t_object *objs, t_ray light_ray, double light_len)
{
	t_hit_record rec;

	rec.tmin = 0;
	rec.tmax = light_len;
	if (hit(objs, &light_ray, &rec))
		return (TRUE);
	return (FALSE);
}
```

***Code1 : [miniRT/src/trace/ray/phong_lighting.c]***

처음 출발한 ray가 object에 부딪혔을 때에 그 곳에서 부터 light로 ray를 쏴준다. light로 ray가 가는 중 object에 부딪히게 되면 shadow 안에 존재하는 것이다. object에서 light로 ray를 쏠 때에 rec.tmax는 object와 light의 거리이어야 한다. rmax를 object와 light의 거리보다 길게 잡을 경우 light 뒤에 오브젝트가 있으면 shadow가 생기는 기현상이 발생할 수 있기 때문이다. 여기서 light와 object와의 거리는 light_len이다.

## 9.3. shadow 적용

이제 in_shadow함수를 만들었으니 이를 다른 함수에 적용시켜보자.

```c
t_color3		point_light_get(t_scene *scene, t_light *light)
{
	t_color3	ambient;
	t_color3	diffuse;
	t_color3	specular;
	t_vec3		light_dir;
// 추가
	double		light_len;
	t_ray		light_ray;
// 추가 끝
	t_vec3		view_dir;
	t_vec3		reflect_dir;
  
  ...
    
	double		spec;
	double		brightness;
	// 추가
	light_dir = vminus(light->origin, scene->rec.p);
	light_len = vlength(light_dir);
	light_ray = ray(vplus(scene->rec.p, vmult(scene->rec.normal, EPSILON)), light_dir);
	if (in_shadow(scene->world, light_ray, light_len))
		return (color3(0,0,0));
	light_dir = vunit(light_dir);
  // 추가 끝
	view_dir = vunit(vmult(scene->ray.dir, -1));
  // 제거
  light_dir = vunit(vminus(light->origin, scene->rec.p));
  // 제거 끝
```

***Code2 : [miniRT/src/trace/ray/phong_lighting.c]***

light와 object와의 거리를 구하기 위해 light_len을 만들었다. Light_dir에 light와 rec.p사이의 방향을 저장하고 vlength를 이용하여 light와 object의 거리를 구하여 light_len에 저장한다. 그리고 light_ray에 rec.p에서 light로 쏜 ray를 저장하고 in_shadow에 넣어준다. 여기서 shadow안에 있다고 판단되면 빛이 전혀 없다고 판단하고 color(0, 0, 0)을 리턴한다.

![not_in_shadow](./images/09_image1.jpg)

**이미지1. not_in_shadow**



![in_shadow](./images/09_image2.jpg)

**이미지2. in_shadow**



마지막으로 정의한 함수를 선언하고 main에서 object를 배치해보자.

``` c
t_color3	point_light_get(t_scene *scene, t_light *light);
// 추가
t_bool		in_shadow(t_object *objs, t_ray light_ray, double light_len);
// 추가 끝

// trace/hit/
t_bool		hit(t_object *obj, t_ray *ray, t_hit_record *rec);
```

***Code3 : [miniRT/include/trace.h]***

in_shadow를 선언해주었다.

``` c
scene->camera = camera(&scene->canvas, point3(0, 0, 0));
	world = object(SP, sphere(point3(-2, 0, -5), 2), color3(0.5, 0, 0)); // world 에 구1 추가
// 추가
	oadd(&world, object(SP, sphere(point3(0, -1000, 0), 995), color3(1, 1, 1))); // world 에 구3 추가
// 추가 끝
	oadd(&world, object(SP, sphere(point3(2, 0, -5), 2), color3(0, 0.5, 0))); // world 에 구2 추가
	scene->world = world;
// 추가
	lights = object(LIGHT_POINT, light_point(point3(0, 20, 0), color3(1, 1, 1), 0.5), color3(0, 0, 0)); // 더미 albedo
// 추가 끝
	scene->light = lights;
	return (scene);
```

***Code4 :  [miniRT/src/main.c]***

이번 단원에서 구현한 shadow를 확인하기 위해서 object의 배치를 조정하였다.



이번 단원의 결과물은 다음과 같다.

![in_shadow](./images/09_image3.jpg)

**이미지3. 그림자 적용한 결과**

